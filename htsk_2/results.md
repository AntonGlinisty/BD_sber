## Развернем redis в docker контейнере

#### Создание образа:

```
docker build -t redis .
```

#### Запуск контейнера:

```
docker run -w /volumes --name redis -d redis
```

#### Заходим в контейнер для выполнения скрипта:

```
docker exec -it redis bash
```

#### Запуск скрипта:

```
python3 main.py
```

#### Результаты:

<image src="./screenshots/time.jpeg">

## Развернем кластер redis в docker контейнерах

#### Поднятие контейнеров:

```
docker compose up -d
```

#### Связь нод друг с другом

```
docker exec -it node1 redis-cli --cluster create \
 node1:7000 node2:7001 node3:7002 --cluster-replicas 0
```

#### Проверка статуса redis кластера

```
docker exec -it node1 redis-cli --cluster check node1:7000
```

#### Заходим в один из контейнеров для выполнения скрипта:

```
docker exec -it node1 bash
```

#### Устанавливаем дополнительную зависимость:
```
apt install python3-rediscluster
```

#### Запуск скрипта:
```
python3 /volumes/cluster.py
```

#### Результаты:

<image src="./screenshots/cluster.jpeg">

#### Вывод:
##### Время на сохранение данных на кластере увеличилось. Вероятно, это связано с синхронизацией данных между нодами.
##### Время на чтение данных для некоторых структур данных несколько увеличилось, а для некоторых осталось тем же. Если данные не разнеслись на разные ноды в результате шардирования, то прочитать их можно с одной ноды, что не требует дополнительных временных затрат.